<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Crafting perfect Java Docker build flow | Terra Nullius</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Crafting perfect Java Docker build flow" />
<meta name="author" content="Alexei Lednev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TL;DR" />
<meta property="og:description" content="TL;DR" />
<link rel="canonical" href="http://localhost:4000/devops/2017/03/07/perfect-docker-java.html" />
<meta property="og:url" content="http://localhost:4000/devops/2017/03/07/perfect-docker-java.html" />
<meta property="og:site_name" content="Terra Nullius" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-07T18:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Crafting perfect Java Docker build flow" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alexei Lednev"},"dateModified":"2017-03-07T18:00:00+02:00","datePublished":"2017-03-07T18:00:00+02:00","description":"TL;DR","headline":"Crafting perfect Java Docker build flow","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/devops/2017/03/07/perfect-docker-java.html"},"url":"http://localhost:4000/devops/2017/03/07/perfect-docker-java.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Terra Nullius" />
<!-- Custom head content -->

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

<!-- Additional custom styles -->
<style>
  body {
    font-family: 'Roboto', sans-serif;
  }
  .site-title {
    font-weight: 700;
  }
  .post-content img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
  }
  pre, code {
    border-radius: 4px;
  }
  .post-tag {
    display: inline-block;
    background-color: #f0f0f0;
    padding: 2px 8px;
    border-radius: 3px;
    margin-right: 5px;
    font-size: 0.8em;
  }
</style>

<!-- Favicon -->
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
</head>
<body><header class="site-header">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Terra Nullius</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Alexei Lednev&#39;s Blog</a></div>
      </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Crafting perfect Java Docker build flow</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-03-07T18:00:00+02:00" itemprop="datePublished">Mar 7, 2017
      </time></p>
      
    
    <div class="post-tags">
      <strong>Tags:</strong>
      
        <span class="post-tag">docker</span>
      
        <span class="post-tag">tutorial</span>
      
        <span class="post-tag">devops</span>
      
        <span class="post-tag">hacks</span>
      
        <span class="post-tag">java</span>
      
        <span class="post-tag">maven</span>
      
    </div>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="tldr">TL;DR</h2>
<blockquote>
<p><em>What is the bare minimum you need to <strong>build</strong>, <strong>test</strong> and <strong>run</strong> my Java application in Docker container?</em></p>
</blockquote>
<blockquote>
<p><strong>The recipe:</strong> Create a separate Docker image for each step and optimize the way you are running it.</p>
</blockquote>
<p><img src="/assets/images/duke_docker.png" alt="Duke and Container" /></p>
<h2 id="introduction">Introduction</h2>
<p>I started working with Java in 1998, and for a long time, it was my main programming language. It was a long love–hate relationship.</p>
<p>DDuring my work career, I wrote a lot of code in Java. Despite that fact, I don’t think Java is usually the right choice for writing microservices running in <a href="https://www.docker.com/">Docker</a> containers.</p>
<p>But, sometimes you have to work with Java. Maybe Java is your favorite language and you do not want to learn a new one, or you have a legacy code that you need to maintain, or your company decided on Java and you have no other option.</p>
<p>Whatever reason you have to <strong><em>marry Java with Docker</em></strong>, you better <strong><em>do it properly</em></strong>.</p>
<p>In this post, I will show you how to create an effective Java-Docker build pipeline to consistently produce small, efficient, and secure Docker images.</p>
<h2 id="be-careful">Be careful</h2>
<p>There are plenty of <em>“Docker for Java developers”</em> tutorials out there, that unintentionally encourage some Docker bad practices.</p>
<p>For example:</p>
<ul>
<li><a href="https://sparktutorials.github.io/2015/04/14/getting-started-with-spark-and-docker.html">Spark and Docker tutorial</a></li>
<li><a href="https://examples.javacodegeeks.com/devops/docker/introduction-docker-java-developers/">Introducing Docker for Java Developers</a></li>
<li><a href="http://www.developer.com/java/data/using-java-with-docker-engine.html">Using Java with Docker Engine</a></li>
<li>and others ...</li>
</ul>
<p>For current demo project, first two tutorials took around 15 minutes to build (first build) and produced images of 1.3GB size each.</p>
<blockquote>
<p>Make yourself a favor and do not follow these tutorials!</p>
</blockquote>
<h2 id="what-should-you-know-about-docker">What should you know about Docker?</h2>
<p>Developers new to Docker are often tempted to think of it as just another VM. Instead, think of Docker as a “child process”. The files and packages needed for an entire VM are different from those needed by just another process running a dev machine. Docker is even better than a child process because it allows better isolation and environmental control.</p>
<p>If you’re new to Docker, I suggest reading this <a href="https://docs.docker.com/engine/understanding-docker/">Understanding Docker</a> article. Docker isn’t so complex than any developer should not be able to understand how it works.</p>
<h2 id="dockerizing-java-application">Dockerizing Java application</h2>
<h3 id="what-files-need-to-be-included-in-a-java-applications-docker-image">What files need to be included in a Java Application’s Docker image?</h3>
<p>Since Docker containers are just isolated processes, your Java Docker image should only contain the files required to run your application.</p>
<p><em>What are these files?</em></p>
<p>It starts with a Java Runtime Environment (<strong>JRE</strong>). <strong>JRE</strong> is a software package, that has everything required to run a Java program. It includes an implementation of the Java Virtual Machine (<strong>JVM</strong>) with an implementation of the <em>Java Class Library</em>.</p>
<p>I recommend using <a href="http://openjdk.java.net/">OpenJDK</a> JRE. OpenJDK is licensed under <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a> with <a href="http://www.gnu.org/software/classpath/license.html">Classpath Exception</a>. The <em>Classpath Exception</em> part is important. This license allows using OpenJDK with any software of any license, not just the GPL. In particular, you can use OpenJDK in proprietary software without disclosing your code.</p>
<p>Before using Oracle’s JDK/JRE, please read the following post: <a href="http://blog.takipi.com/running-java-on-docker-youre-breaking-the-law/">“Running Java on Docker? You’re Breaking the Law.”</a></p>
<p>Since it’s rare for Java applications to be developed using only the standard library, you most likely need to also add 3rd party Java libraries. Then add the application compiled bytecode as plain <em>Java Class</em> files or packaged into <em>JAR</em> archives. And, if you are using native code, you will need to add corresponding native libraries/packages too.</p>
<h3 id="choosing-a-base-docker-image-for-java-application">Choosing a base Docker image for Java Application</h3>
<p>In order to choose the base Docker image, you need to answer the following questions:</p>
<ul>
<li><em>What native packages do you need for your Java application?</em></li>
<li><em>Should you choose Ubuntu or Debian as your base image?</em></li>
<li><em>What is your strategy for patching security holes, including packages you are not using at all?</em></li>
<li><em>Do you mind paying extra (money and time) for network traffic and storage of unused files?</em></li>
</ul>
<p>Some might say: <em>“but, if all your images share the same Docker layers, you only download them just once, right?”</em></p>
<p>That’s <em>true</em> in theory, but in reality is often very different.</p>
<p>Usually, you have lots of different images: some you built lately, others a long time ago, others you pull from DockerHub. All these images do not share the same base image or version. You need to invest a lot of time to align these images to share the same base image and then keep these images up-to-date.</p>
<p>Some might say: <em>“but, who cares about image size? we download them just once and run forever”</em>.</p>
<p>Docker image size is actually very important.</p>
<p>The size has an impact on …</p>
<ul>
<li><strong>network latency</strong> - need to transfer Docker image over the web</li>
<li><strong>storage</strong> - need to store all these bits somewhere</li>
<li><strong>service availability and elasticity</strong> - when using a Docker scheduler, like Kubernetes, Swarm, DC/OS or other (scheduler can move containers between hosts)</li>
<li><strong>security</strong> - do you really, I mean really need the libpng package with all its <a href="https://www.cvedetails.com/vulnerability-list/vendor_id-7294/Libpng.html">CVE vulnerabilities</a> for your Java application?</li>
<li><strong>development agility</strong> - small Docker images == faster build time and faster deployment</li>
</ul>
<p>Without being careful, Java Docker images tends to grow to enormous sizes. I’ve seen 3GB Java images, where the real code and required JAR libraries only take around 150MB.</p>
<p>Consider using <a href="https://hub.docker.com/_/alpine/">Alpine Linux image</a>, which is only a 5MBs image, as a base Docker image. Lots of <a href="https://github.com/docker-library/official-images">&quot;Official Docker images&quot;</a> have an Alpine-based flavor.</p>
<p><strong>Note</strong>: Many, but not all Linux packages have versions compiled with <code>musl libc</code> C runtime library. Sometimes you want to use a package that is compiled with <code>glibc</code> (GNU C runtime library). The <a href="https://hub.docker.com/r/frolvlad/alpine-glibc/">frolvlad/alpine-glibc</a> image based on Alpine Linux image and contains <code>glibc</code> to enable proprietary projects, compiled against <code>glibc</code> (e.g. OracleJDK, Anaconda), working on Alpine.</p>
<h3 id="choosing-the-right-java-application-server">Choosing the right Java Application server</h3>
<p>Frequently, you also need to expose some kind of interface to reach your Java application, that runs in a Docker container.</p>
<p>When you deploy Java applications with Docker containers, the default Java deployment model changes.</p>
<p>Originally, Java server-side deployment assumes that you have already pre-configured a Java Web Server (Tomcat, WebLogic, JBoss, or other) and you are deploying an application <strong>WAR</strong> (Web Archive) packaged Java application to this server and run it together with other applications, deployed on the same server.</p>
<p>Lots of tools are developed around this concept, allowing you to update running applications without stopping the Java Application server, route traffic to the new application, resolve possible class loading conflicts and more.</p>
<p>With Docker-based deployments, you do not need these tools anymore, you don't even need the fat &quot;enterprise-ready&quot; Java Application servers. The only thing that you need is a stable and scalable network server that can serve your API over HTTP/TCP or other protocol of your choice. Search Google for [“embedded Java server”](<a href="https://www.google.com/search?q=%22embedded">https://www.google.com/search?q=&quot;embedded</a> java server&quot;) and take one that you like most.</p>
<p>For this demo, I forked <a href="https://github.com/khoubyari/spring-boot-rest-example">Spring Boot's REST example</a> and modified it a bit. The demo uses <a href="https://projects.spring.io/spring-boot/">Spring Boot</a> with an embedded <a href="http://tomcat.apache.org/">Tomcat</a> server. Here is my <a href="https://github.com/alexei-led/spring-boot-rest-example">fork</a> on GitHub repository (<code>blog</code> branch).</p>
<h3 id="building-a-java-application-docker-image">Building a Java Application Docker image</h3>
<p>In order to run this demo, I need to create a Docker image with JRE, the compiled and packaged Java application, and all 3rd party libraries.</p>
<p>Here is the <code>Dockerfile</code> I used to build my Docker image. This demo Docker image is based on slim Alpine Linux with OpenJDK JRE and contains the application WAR file with all dependencies embedded into it. It's just the bare minimum required to run the demo application.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Base Alpine Linux based image with OpenJDK JRE only</span>
<span class="k">FROM</span><span class="s"> openjdk:8-jre-alpine</span>

<span class="c"># copy application WAR (with libraries inside)</span>
<span class="k">COPY</span><span class="s"> target/spring-boot-*.war /app.war</span>

<span class="c"># specify default command</span>
<span class="k">CMD</span><span class="s"> ["/usr/bin/java", "-jar", "-Dspring.profiles.active=test", "/app.war"]</span>
</code></pre></div></div>
<p>To build the Docker image, run the following command:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> blog/sbdemo:latest <span class="nb">.</span>
</code></pre></div></div>
<p>Running the <code>docker history</code> command on created Docker image will let you to see all layers that make up this image:</p>
<ul>
<li>4.8MB Alpine Linux Layer</li>
<li>103MB OpenJDK JRE Layer</li>
<li>61.8MB Application WAR file</li>
</ul>
<pre><code>$ docker history blog/sbdemo:latest

IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
16d5236aa7c8        About an hour ago   /bin/sh -c #(nop)  CMD [&quot;/usr/bin/java&quot; &quot;-...   0 B                 
e1bbd125efc4        About an hour ago   /bin/sh -c #(nop) COPY file:1af38329f6f390...   61.8 MB             
d85b17c6762e        2 months ago        /bin/sh -c set -x  &amp;&amp; apk add --no-cache  ...   103 MB              
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  ENV JAVA_ALPINE_VERSION...   0 B                 
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  ENV JAVA_VERSION=8u111       0 B                 
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  ENV PATH=/usr/local/sbi...   0 B                 
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  ENV JAVA_HOME=/usr/lib/...   0 B                 
&lt;missing&gt;           2 months ago        /bin/sh -c {   echo '#!/bin/sh';   echo 's...   87 B                
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0 B                 
&lt;missing&gt;           2 months ago        /bin/sh -c #(nop) ADD file:eeed5f514a35d18...   4.8 MB              
</code></pre>
<h3 id="running-the-java-application-docker-container">Running the Java Application Docker container</h3>
<p>In order to run the demo application, run following command:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--name</span> demo-default <span class="nt">-p</span> 8090:8090 <span class="nt">-p</span> 8091:8091 blog/sbdemo:latest
</code></pre></div></div>
<p>Let's check, that application is up and running (I’m using the <code>httpie</code> tool here):</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>http http://localhost:8091/info

HTTP/1.1 200 OK
Content-Type: application/json
Date: Thu, 09 Mar 2017 14:43:28 GMT
Server: Apache-Coyote/1.1
Transfer-Encoding: chunked

<span class="o">{</span>
    <span class="s2">"build"</span>: <span class="o">{</span>
        <span class="s2">"artifact"</span>: <span class="s2">"</span><span class="k">${</span><span class="nv">project</span><span class="p">.artifactId</span><span class="k">}</span><span class="s2">"</span>,
        <span class="s2">"description"</span>: <span class="s2">"boot-example default description"</span>,
        <span class="s2">"name"</span>: <span class="s2">"spring-boot-rest-example"</span>,
        <span class="s2">"version"</span>: <span class="s2">"0.1"</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<h4 id="setting-docker-container-memory-constraints">Setting Docker container memory constraints</h4>
<p>One thing you need to know about Java process memory allocation is that in reality it consumes more physical memory than specified with the <code>-Xmx</code> JVM option. The <code>-Xmx</code> option specifies only the maximum Java heap size. But the Java process is a regular Linux process and what is interesting, is how much actual physical memory this process is consuming.</p>
<p>Or in other words - <em>what is the <strong>Resident Set Size</strong> (<strong>RSS</strong>) value for running a Java process?</em></p>
<p>Theoretically, in the case of a Java application, a required RSS size can be calculated by:</p>
<pre><code>RSS = Heap size + MetaSpace + OffHeap size
</code></pre>
<p>where <em>OffHeap</em> consists of thread stacks, direct buffers, mapped files (libraries and jars) and JVM code itself.</p>
<p>There is a very good post on this topic: <a href="http://trustmeiamadeveloper.com/2016/03/18/where-is-my-memory-java/">Analyzing java memory usage in a Docker container</a> by Mikhail Krestjaninoff.</p>
<p>When using the  <code>--memory</code>  option in <code>docker run</code> make sure the limit is larger (at least twice) than what you specify for <code>-Xmx</code>.</p>
<h4 id="offtopic-using-oom-killer-instead-of-gc">Offtopic: Using OOM Killer instead of GC</h4>
<p>There is an interesting <strong>JDK Enhancement Proposal (JEP)</strong> by Aleksey Shipilev: [Epsilon GC]((<a href="http://openjdk.java.net/jeps/8174901">http://openjdk.java.net/jeps/8174901</a>). This JEP proposes to develop a GC that only handles memory allocation, but does not implement any actual memory reclamation mechanism.</p>
<p>This GC, combined with <code>--restart</code> (Docker restart policy) should theoretically allow supporting “Extremely short lived jobs” implemented in Java.</p>
<p>For ultra-performance-sensitive applications, where developers are conscious about memory allocations or want to create completely garbage-free applications - GC cycle may be considered an implementation bug that wastes cycles for no good reason. In such use case, it could be better to allow <strong>OOM Killer</strong> (Out of Memory) to kill the process and use Docker restart policy to restarting the process.</p>
<p>Anyway, <strong>Epsilon GC</strong> is not available yet, so it’s just an interesting theoretical use case for a moment.</p>
<h2 id="building-java-applications-with-builder-container">Building Java applications with Builder container</h2>
<p>As you can probably see, in the previous step, I did not explain how I’ve created the application WAR file.</p>
<p>Of course, there is a Maven project file <code>pom.xml</code> which most Java developers should be familiar with. But, in order to actually build, you need to install the <em>same Java Build tools</em> (JDK and Maven) on <em>every machine</em>, where you are building the application. You need to have the same versions, use the same repositories and share the same configurations. While's tt’s possible, managing different projects that rely on different tools, versions, configurations, and development environments can quickly become a nightmare.</p>
<p>What if you might also want to run a build on a clean machine that does not have Java or Maven installed? <em>What should you do?</em></p>
<h3 id="java-builder-container">Java Builder Container</h3>
<p>Docker can help here too. With Docker, you can create and share portable development and build environments. The idea is to create a special <strong>Builder</strong> Docker image, that contains all tools you need to properly build your Java application, e.g.: JDK, Ant, Maven, Gradle, SBT or others.</p>
<p>To create a really useful <strong>Builder</strong> Docker image, you need to know well how you Java Build tools are working and how <code>docker build</code> invalidates build cache. Without proper design, you will end up with non-effective and slow builds.</p>
<h3 id="running-maven-in-docker">Running Maven in Docker</h3>
<p>While most of these tools were created nearly a generation ago, they are still are very popular and widely used by Java developers.</p>
<p>Java development life is hard to imagine without some extra build tools. There are multiple Java build tools out there, but most of them share similar concepts and serve the same targets - resolve cumbersome package dependencies, and run different build tasks, such as, <strong>compile, lint, test, package, and deploy</strong>.</p>
<p>In this post, I will use <a href="https://maven.apache.org">Maven</a>, but the same approach can be applied to <a href="https://gradle.org/">Gradle</a>, <a href="http://www.scala-sbt.org/">SBT</a>, and other less popular Java Build tools.</p>
<p>It’s important to learn how your Java Build tool works and how can it's tuned. Apply this knowledge, when creating a <strong>Builder</strong> Docker image and the way you are running a <strong>Builder</strong> Docker container.</p>
<p>Maven uses the project level <code>pom.xml</code> file to resolve project dependencies. It downloads missing <code>JAR</code> files from private and public Maven repositories, and <em>caches</em> these files for future builds. Thus, next time you run your build, it won’t download anything if your dependency had not been changed.</p>
<h4 id="official-maven-docker-image-should-you-use-it">Official Maven Docker image: should you use it?</h4>
<p>The Maven team provides an official <a href="https://hub.docker.com/r/_/maven/">Docker images</a>. There are multiple images (under different tags) that allow you to select an image that can answer your needs. Take a deeper look at the <code>Dockerfile</code> files and <code>mvn-entrypoint.sh</code> shell scripts when selecting Maven image to use.</p>
<p>There are two flavors of official Maven Docker images: regular images (JDK version, Maven version, and Linux distro) and <code>onbuild</code> images.</p>
<h5 id="what-is-the-official-maven-image-good-for">What is the official Maven image good for?</h5>
<p>The official Maven image does a good job containerizing the Maven tool itself. The image contains some JDK and Maven version. Using such image, you can run Maven build on any machine without installing a JDK and Maven.</p>
<p><strong>Example:</strong> running <code>mvn clean install</code> on local folder</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> my-maven-project <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>:/usr/src/app <span class="nt">-w</span> /usr/src/app maven:3.2-jdk-7 mvn clean <span class="nb">install</span>
</code></pre></div></div>
<p>Maven local repository, for official Maven images, is placed inside a Docker <em>data volume</em>. That means, all downloaded dependencies <strong>are not part of the image</strong> and <strong>will disappear</strong> once the Maven container is destroyed. If you do not want to download dependencies on every build, mount Maven repository Docker volume to some persistent storage (at least local folder on the Docker host).</p>
<p><strong>Example:</strong> running <code>mvn clean install</code> on local folder with properly mounted Maven local repository</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--name</span> my-maven-project <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>:/usr/src/app <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span>/.m2:/root/.m2 <span class="nt">-w</span> /usr/src/app maven:3.2-jdk-7 mvn clean <span class="nb">install</span>
</code></pre></div></div>
<p>Now, let's take a look at onbuild Maven Docker images.</p>
<h5 id="what-is-maven-codeonbuildcode-image">What is Maven <code>onbuild</code> image?</h5>
<p>Maven <code>onbuild</code> Docker image exists to <em>“simplify”</em> developer’s life, allowing him/er skip writing a <code>Dockerfile</code>. Actually, a developer should write a <code>Dockerfile</code>, but it’s usually enough to have the single line in it:</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> maven:&lt;versions&gt;-onbuild</span>
</code></pre></div></div>
<p>Looking into onbuild Dockerfile on the GitHub repository …</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> maven:&lt;version&gt;</span>

<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /usr/src/app
<span class="k">WORKDIR</span><span class="s"> /usr/src/app</span>

<span class="k">ONBUILD</span><span class="w"> </span><span class="k">ADD</span><span class="s"> . /usr/src/app</span>
<span class="k">ONBUILD RUN </span>mvn <span class="nb">install</span>
</code></pre></div></div>
<p>… you can see several <code>Dockerfile</code> commands with the ONBUILD prefix. The <code>ONBUILD</code> tells Docker to postpone the execution of these build commands until building a new image that inherits from the current image.</p>
<p>In our example, two build commands will be executed, when you build the application <code>Dockerfile</code> created <code>FROM: maven:&lt;version&gt;-onbuild</code> :</p>
<ul>
<li>Add current folder (all files, if you are not using <code>.dockerignore</code>) to the new Docker image</li>
<li>Run <code>mvn install</code> Maven target</li>
</ul>
<p>The <code>onbuild</code> Maven Docker image is not as useful as the previous image.</p>
<p>First of all, it copies everything from the current repository, so do not use it without a properly configured <code>.dockerignore</code> file.</p>
<p>Then, think: <em>what kind of image you are trying to build?</em></p>
<p>The new image, created from <code>onbuild</code>  Maven Docker image, includes JDK, Maven, application code (and potentially <strong>all files</strong> from current directory), and <strong>all files</strong> produced by Maven <code>install</code> phase (compiled, tested and packaged app; plus lots of build junk files you do not really need).</p>
<p>So, this Docker image contains everything, but, for some strange reason, does not contain a local Maven repository. I have no idea why the Maven team created this image.</p>
<blockquote>
<p><strong>Recommendation:</strong> Do not use Maven onbuild images!</p>
</blockquote>
<p>If you just want to use Maven tool, use non-onbuild image.</p>
<p>If you want to create proper Builder image, I will show you how to do this later in this post.</p>
<h4 id="where-to-keep-maven-cache">Where to keep Maven cache?</h4>
<p>Official Maven Docker image chooses to keep Maven cache folder outside of the container, exposing it as a Docker <em>data volume</em>, using <code>VOLUME root/.m2</code> command in the <code>Dockerfile</code>. A Docker data volume is a directory within one or more containers that bypasses the Docker Union File System, in simple words: it’s not part of the Docker image.</p>
<p>What you should know about Docker <em>data volumes</em>:</p>
<ul>
<li>Volumes are initialized when a container is created.</li>
<li>Data volumes can be shared and reused among containers.</li>
<li>Changes to a data volume are made directly to the mounted endpoint (usually some directory on host, but can be some storage device too)</li>
<li>Changes to a data volume will not be included when you update an image or persist Docker container.</li>
<li>Data volumes persist even if the container itself is deleted.</li>
</ul>
<p>So, in order to <em>reuse</em> Maven <em>cache</em> between different builds, mount a Maven <em>cache data volume</em> to some persistent storage (for example, a local directory on the Docker host).</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">--volume</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>/pom.xml://usr/src/app/pom.xml <span class="nt">--volume</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span>/.m2:/root/.m2 maven:3-jdk-8-alpine mvn <span class="nb">install</span>
</code></pre></div></div>
<p>The command above runs the official Maven Docker image (Maven 3 and OpenJDK 8), mounts project <code>pom.xml</code> file into working directory and <code>$HOME&quot;/.m2</code> folder for Maven <em>cache data volume</em>. Maven running inside this Docker container will download all required JAR files into host’s local</p>
<p>Maven running inside this Docker container will download all required <code>JAR</code> files into host’s local folder <code>$HOME/.m2</code>. Next time you create new Maven Docker container for the same <code>pom.xml</code> file and the same <em>cache</em> mount, Maven will reuse the <em>cache</em> and will download only missing or updated <code>JAR</code> files.</p>
<h4 id="maven-builder-docker-image">Maven Builder Docker image</h4>
<p>First, let’s try to formulate <em>what is the <strong>Builder</strong> Docker image and what should it contain?</em></p>
<blockquote>
<p><strong>Builder</strong> is a Docker image that contains <strong>everything</strong> to allow you creating a reproducible build on any machine and at any point of time.</p>
</blockquote>
<p>So, <em>what should it contain?</em></p>
<ul>
<li>Linux shell and some tools - I prefer Alpine Linux</li>
<li>JDK (version) - for the <code>javac</code> compiler</li>
<li>Maven (version) - Java build tool</li>
<li>Application source code and <code>pom.xml</code> file/s - it’s the application code <code>SNAPSHOT</code> at specific point of time; just code, no need to include a <code>.git</code> repository or other files</li>
<li>Project dependencies (Maven local repository) - all <code>POM</code> and <code>JAR</code> files you need to build and test Java application, at any time, even offline, even if library disappear from the web</li>
</ul>
<p>The <strong>Builder</strong> image captures code, dependencies, and tools at a specific point of time and stores them inside a Docker image. The <strong>Builder</strong> container can be used to create the application “binaries” on any machine, at any time and even without internet connection (or with poor connection).</p>
<p>Here is the sample <code>Dockerfile</code> for my demo <strong>Builder</strong>:</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> openjdk:8-jdk-alpine</span>

<span class="c"># ----</span>
<span class="c"># Install Maven</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> curl <span class="nb">tar </span>bash

<span class="k">ARG</span><span class="s"> MAVEN_VERSION=3.3.9</span>
<span class="k">ARG</span><span class="s"> USER_HOME_DIR="/root"</span>

<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /usr/share/maven <span class="o">&amp;&amp;</span> <span class="se">\
</span>  curl <span class="nt">-fsSL</span> http://apache.osuosl.org/maven/maven-3/<span class="nv">$MAVEN_VERSION</span>/binaries/apache-maven-<span class="nv">$MAVEN_VERSION</span><span class="nt">-bin</span>.tar.gz | <span class="nb">tar</span> <span class="nt">-xzC</span> /usr/share/maven <span class="nt">--strip-components</span><span class="o">=</span>1 <span class="o">&amp;&amp;</span> <span class="se">\
</span>  <span class="nb">ln</span> <span class="nt">-s</span> /usr/share/maven/bin/mvn /usr/bin/mvn

<span class="k">ENV</span><span class="s"> MAVEN_HOME /usr/share/maven</span>
<span class="k">ENV</span><span class="s"> MAVEN_CONFIG "$USER_HOME_DIR/.m2"</span>
<span class="c"># speed up Maven JVM a bit</span>
<span class="k">ENV</span><span class="s"> MAVEN_OPTS="-XX:+TieredCompilation -XX:TieredStopAtLevel=1"</span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/usr/bin/mvn"]</span>

<span class="c"># ----</span>
<span class="c"># Install project dependencies and keep sources </span>

<span class="c"># make source folder</span>
<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /usr/src/app
<span class="k">WORKDIR</span><span class="s"> /usr/src/app</span>

<span class="c"># install maven dependency packages (keep in image)</span>
<span class="k">COPY</span><span class="s"> pom.xml /usr/src/app</span>
<span class="k">RUN </span>mvn <span class="nt">-T</span> 1C <span class="nb">install</span> <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> target

<span class="c"># copy other source files (keep in image)</span>
<span class="k">COPY</span><span class="s"> src /usr/src/app/src</span>
</code></pre></div></div>
<p>Let’s go over this <code>Dockerfile</code> and I will try to explain the reasoning behind each command.</p>
<ul>
<li><code>FROM: openjdk:8-jdk-alpine</code> - select and freeze JDK version: OpenJDK 8 and Linux Alpine</li>
<li>Install Maven
<ul>
<li><code>ARG ...</code> - Use build arguments to allow overriding Maven version and local repository location (<code>MAVEN_VERSION</code> and <code>USER_HOME_DIR</code>) with <code>docker build --build-arg ...</code></li>
<li><code>RUN mkdir -p ... curl ... tar ...</code> - Download and install (<code>untar</code> and <code>ln -s</code>) Apache Maven</li>
<li>Speed up Maven JVM a bit: <code>MAVEN_OPTS=&quot;-XX:+TieredCompilation -XX:TieredStopAtLevel=1&quot;</code>, read the following <a href="https://zeroturnaround.com/rebellabs/your-maven-build-is-slow-speed-it-up/">post</a></li>
</ul>
</li>
<li><code>RUN mvn -T 1C install &amp;&amp; rm -rf target</code> Download project dependencies:
<ul>
<li>Copy project <code>pom.xml</code> file and run <code>mvn install</code> command and remove build artifacts as far as I know, there is no Maven command that will let you download without installing)</li>
<li>This Docker image layer will be rebuilt only when project’s <code>pom.xml</code> file changes</li>
</ul>
</li>
<li><code>COPY src /usr/src/app/src</code> - copy project source files (source, tests, and resources)</li>
</ul>
<p><strong>Note:</strong> if you are using <a href="http://maven.apache.org/surefire/maven-surefire-plugin">Maven Surefire plugin</a> and want to have all dependencies for the offline build, make sure to <a href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/providers.html">lock down Surefire test provider</a>.</p>
<p>When you build a new <strong>Builder</strong> version, I suggest you use a <code>--cache-from</code> option passing previous Builder image to it. This will allow you reuse any unmodified Docker layer and avoid obsolete downloads most of the time (if <code>pom.xml</code> did not change or you did not decide to upgrade Maven or JDK).</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="c"># pull latest (or specific version) builder image</span>
<span class="nv">$ </span>docker pull myrep/mvn-builder:latest
<span class="nv">$ </span><span class="c"># build new builder</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> myrep/mvn-builder:latest <span class="nt">--cache-from</span> myrep/mvn-builder:latest <span class="nb">.</span>
</code></pre></div></div>
<h5 id="use-builder-container-to-run-tests">Use Builder container to run tests</h5>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="c"># run tests - test results are saved into $PWD/target/surefire-reports</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>/target:/usr/src/app/target myrep/mvn-builder <span class="nt">-T</span> 1C <span class="nt">-o</span> <span class="nb">test</span>
</code></pre></div></div>
<h5 id="use-builder-container-to-create-application-war">Use Builder container to create application WAR</h5>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="c"># create application WAR file (skip tests) - $PWD/target/spring-boot-rest-example-0.3.0.war</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">-v</span> <span class="si">$(</span>shell <span class="nb">pwd</span><span class="si">)</span>/target:/usr/src/app/target myrep/mvn-builder package <span class="nt">-T</span> 1C <span class="nt">-o</span> <span class="nt">-Dmaven</span>.test.skip<span class="o">=</span><span class="nb">true</span>
</code></pre></div></div>
<h2 id="summary">Summary</h2>
<p>Take a look at images bellow:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPOSITORY      TAG     IMAGE ID     CREATED        SIZE
sbdemo/run      latest  6f432638aa60 7 minutes ago  143 MB
sbdemo/tutorial 1       669333d13d71 12 minutes ago 1.28 GB
sbdemo/tutorial 2       38634e4d9d5e 3 hours ago    1.26 GB
sbdemo/builder  mvn     2d325a403c5f 5 days ago     263 MB
</code></pre></div></div>
<ul>
<li><code>sbdemo/run:latest</code> - Docker image for demo runtime: Alpine, OpenJDK JRE only, demo WAR</li>
<li><code>sbdemo/builder:mvn</code> - <strong>Builder</strong> Docker image: Alpine, OpenJDK 8, Maven 3, code, dependency</li>
<li><code>sbdemo/tutorial:1</code> - Docker image created following first tutorial (just for reference)</li>
<li><code>sbdemo/tutorial:2</code> - Docker image created following second tutorial (just for reference)</li>
</ul>
<h2 id="bonus-build-flow-automation">Bonus: Build flow automation</h2>
<p>In this section, I will show how to use Docker build flow automation service to automate and orchestrate all steps from this post.</p>
<h3 id="build-pipeline-steps">Build Pipeline Steps</h3>
<p>I'm going to use <a href="https://codefresh.io">Codefresh.io</a> Docker CI/CD service (the company I'm working for) to create a <strong>Builder</strong> Docker image for Maven, run tests, create application WAR, build Docker image for application and deploy it to DockerHub.</p>
<p>The Codefresh automation flow <code>YAML</code> (also called <em>pipeline</em>) is pretty straight forward:</p>
<ul>
<li>it contains ordered list of steps</li>
<li>each step can be of type:</li>
<li>
<ul>
<li><code>build</code> - for <code>docker build</code> command</li>
</ul>
</li>
<li>
<ul>
<li><code>push</code> - for <code>docker push</code></li>
</ul>
</li>
<li>
<ul>
<li><code>composition</code> - for creating environment, specified with <code>docker-compose</code></li>
</ul>
</li>
<li>
<ul>
<li><code>freestyle</code> (default if not specified) - for <code>docker run</code> command</li>
</ul>
</li>
<li><code>/codefresh/volume/</code> <em>data volume</em> (<code>git clone</code> and files generated by steps) is mounted into each step</li>
<li>current working directory for each step is set to <code>/codefresh/volume/</code> by default (can be changed)</li>
</ul>
<p>For detailed description and other examples, take a look at the <a href="https://docs.codefresh.io/docs/steps">documentation</a>.</p>
<p>For my demo flow I've created following automation steps:</p>
<ol>
<li><code>mvn_builder</code> - create Maven <strong>Builder</strong> Docker image</li>
<li><code>mv_test</code> - execute tests in <strong>Builder</strong> container, place test results into <code>/codefresh/volume/target/surefire-reports/</code> <em>data volume</em> folder</li>
<li><code>mv_package</code> - create application <code>WAR</code> file, place created file into <code>/codefresh/volume/target/</code> <em>data volume</em> folder</li>
<li><code>build_image</code> - build application Docker image with JRE and application <code>WAR</code> file</li>
<li><code>push_image</code> - tag and push the application Docker image to DockerHub</li>
</ol>
<p>Here is the full Codefresh <code>YAML</code>:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">1.0'</span>

<span class="na">steps</span><span class="pi">:</span>

  <span class="na">mvn_builder</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">build</span>
    <span class="na">description</span><span class="pi">:</span> <span class="s">create Maven builder image</span>
    <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile.build</span>
    <span class="na">image_name</span><span class="pi">:</span> <span class="s">&lt;put_you_repo_here&gt;/mvn-builder</span>

  <span class="na">mvn_test</span><span class="pi">:</span>
    <span class="na">description</span><span class="pi">:</span> <span class="s">run unit tests</span> 
    <span class="na">image</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">commands</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mvn -T 1C -o test</span>
  
  <span class="na">mvn_package</span><span class="pi">:</span>
    <span class="na">description</span><span class="pi">:</span> <span class="s">package application and dependencies into WAR</span> 
    <span class="na">image</span><span class="pi">:</span> <span class="s">$</span>
    <span class="na">commands</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mvn package -T 1C -o -Dmaven.test.skip=true</span>

  <span class="na">build_image</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">build</span>
    <span class="na">description</span><span class="pi">:</span> <span class="s">create Docker image with application WAR</span>
    <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile</span>
    <span class="na">working_directory</span><span class="pi">:</span> <span class="s">$/target</span>
    <span class="na">image_name</span><span class="pi">:</span> <span class="s">&lt;put_you_repo_here&gt;/sbdemo</span>

  <span class="na">push_image</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">push</span>
    <span class="na">description</span><span class="pi">:</span> <span class="s">push application image to DockerHub</span>
    <span class="na">candidate</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>
    <span class="na">tag</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>
    <span class="na">credentials</span><span class="pi">:</span>
      <span class="c1"># set docker registry credentials in project configuration</span>
      <span class="na">username</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>
      <span class="na">password</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$'</span>
</code></pre></div></div>
<hr />
<p>Hope, you find this post useful. I look forward to your comments and any questions you have.</p>
<hr />
<p><em>This is a <strong>working draft</strong> version. The final post version is published at <a href="https://codefresh.io/blog/java_docker_pipeline/">Codefresh Blog</a> on March 22, 2017.</em></p>

  </div><a class="u-url" href="/devops/2017/03/07/perfect-docker-java.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Alexei Lednev</li><li><a class="u-email" href="mailto:alexei.led@gmail.com">alexei.led@gmail.com</a></li></ul>
      </div>

      <div class="footer-col">
        <p>Alexei Lednev&#39;s personal blog</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
      <a href="https://github.com/alexei-led" title="GitHub">
        <svg class="svg-icon grey">
          <use xlink:href="/assets/minima-social-icons.svg#github"></use>
        </svg>
        <span class="username">Github</span>
      </a>
    </li></ul></div>
  </div>
</footer></body>

</html>
