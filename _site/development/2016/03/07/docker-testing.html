<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Testing Strategies for Docker Containers | Terra Nullius</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Testing Strategies for Docker Containers" />
<meta name="author" content="Alexei Lednev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Congratulations! You know how to build a Docker image and are able to compose multiple containers into a meaningful application. Hopefully, you&#39;ve already created a Continuous Delivery pipeline and know how to push your newly created image into production or testing environment." />
<meta property="og:description" content="Congratulations! You know how to build a Docker image and are able to compose multiple containers into a meaningful application. Hopefully, you&#39;ve already created a Continuous Delivery pipeline and know how to push your newly created image into production or testing environment." />
<link rel="canonical" href="http://localhost:4000/development/2016/03/07/docker-testing.html" />
<meta property="og:url" content="http://localhost:4000/development/2016/03/07/docker-testing.html" />
<meta property="og:site_name" content="Terra Nullius" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-03-07T16:39:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Testing Strategies for Docker Containers" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alexei Lednev"},"dateModified":"2016-03-07T16:39:00+02:00","datePublished":"2016-03-07T16:39:00+02:00","description":"Congratulations! You know how to build a Docker image and are able to compose multiple containers into a meaningful application. Hopefully, you&#39;ve already created a Continuous Delivery pipeline and know how to push your newly created image into production or testing environment.","headline":"Testing Strategies for Docker Containers","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/development/2016/03/07/docker-testing.html"},"url":"http://localhost:4000/development/2016/03/07/docker-testing.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Terra Nullius" />
<!-- Custom head content -->

<!-- Basic styles for images and videos -->
<style>
  .post-content img {
    max-width: 100%;
    height: auto;
  }
  
  .video-container {
    position: relative;
    padding-bottom: 56.25%;
    padding-top: 30px; 
    height: 0; 
    overflow: hidden;
    margin-bottom: 20px;
  }
  
  .video-container iframe,
  .video-container object,
  .video-container embed {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body><header class="site-header">
  <div class="wrapper"><a class="site-title" rel="author" href="/%20/">Terra Nullius</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path
              d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Posts</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Testing Strategies for Docker Containers</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-03-07T16:39:00+02:00" itemprop="datePublished">Mar 7, 2016
      </time></p>
      
    
    <div class="post-tags">
      <strong>Tags:</strong>
      
        <span class="post-tag">Docker</span>
      
        <span class="post-tag">testing</span>
      
        <span class="post-tag">integration test</span>
      
        <span class="post-tag">Dockerfile</span>
      
    </div>
    
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Congratulations! You know how to build a Docker image and are able to compose multiple containers into a meaningful application. Hopefully, you've already created a Continuous Delivery pipeline and know how to push your newly created image into production or testing environment.</p>
<blockquote>
<p>Now, the question is - <em>How do we test our Docker containers?</em></p>
</blockquote>
<p>There are multiple testing strategies we can apply. In this post, I'll highlight them presenting benefits and drawbacks for each.</p>
<h2 id="the-quotnaivequot-approach">The &quot;Naive&quot; approach</h2>
<p>This is the default approach for most people. It relies on a CI server to do the job. When taking this approach, the developer is using Docker as a package manager, a better option than the <strong>jar/rpm/deb</strong> approach.
The CI server compiles the application code and executes tests (unit, service, functional, and others). The build artifacts are reused in Docker <strong>build</strong> to produce a new image. This becomes a core deployment artifact. The produced image contains not only application &quot;binaries&quot;, but also a required runtime including all dependencies and application configuration.</p>
<p>We are getting application portability, however, we are loosing the development and testing portability. We're not able to reproduce exactly the same development and testing environment outside the CI. To create a new test environment we'll need to setup the testing tools (correct versions and plugins), configure runtime and OS settings, and get the same versions of test scripts as well as perhaps, the test data.</p>
<p><img src="/assets/images/naive.png" alt="The Naive Testing Strategy" /></p>
<p>To resolve these problems leads us to the next one.</p>
<h2 id="app-amp-test-container-approach">App &amp; Test Container approach</h2>
<p>Here, we try to create a single bundle with the application &quot;binaries&quot; including required packages, testing tools (specific versions), test tools plugins, test scripts, test environment with all required packages.</p>
<p>The benefits of this approach:</p>
<ul>
<li>We have a repeatable test environment - we can run exactly the same tests using the same testing tools - in our CI, development, staging, or production environment</li>
<li>We capture test scripts at a specific point in time so we can always reproduce them in any environment</li>
<li>We do not need to setup and configure our testing tools - they are part of our image</li>
</ul>
<p>This approach has significant drawbacks:</p>
<ul>
<li>Increases the image size - because it contains testing tools, required packages, test scripts, and perhaps even test data</li>
<li>Pollutes image runtime environment with test specific configuration and may even introduce an unneeded dependency (required by integration testing)</li>
<li>We also need to decide what to do with the test results and logs; how and where to export them</li>
</ul>
<p>Here's a simplified <code>Dockerfile</code>. It illustrates this approach.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> "&lt;bases image&gt;":"&lt;version&gt;"</span>

<span class="k">WORKDIR</span><span class="s"> "&lt;path&gt;"</span>

<span class="c"># install packages required to run app and tests</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\
</span>    <span class="s2">"&lt;app runtime&gt; and &lt;dependencies&gt;"</span> <span class="se">\ </span> <span class="c"># add app runtime and required packages</span>
    "&lt;test tools&gt; and &lt;dependencies&gt;" \     # add testing tools and required packages
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# copy app files
<span class="k">COPY</span><span class="s"> app app</span>
<span class="k">COPY</span><span class="s"> run.sh run.sh</span>

<span class="c"># copy test scripts</span>
<span class="k">COPY</span><span class="s"> tests tests</span>

<span class="c"># copy "main" test command</span>
<span class="k">COPY</span><span class="s"> test.sh test.sh</span>

<span class="c"># ... EXPOSE, RUN, ADD ... for app and test environment</span>

<span class="c"># main app command</span>
<span class="k">CMD</span><span class="s"> [run.sh, "&lt;app arguments&gt;"]</span>

<span class="c"># it's not possible to have multiple CMD commands, but this is the "main" test command</span>
<span class="c"># CMD [/test.sh, "&lt;test arguments&gt;"]</span>
</code></pre></div></div>
<p><a href="https://gist.github.com/alexei-led/cbb3d46fcf422a24aacd">Dockerfile</a></p>
<p><img src="/assets/images/app_test.png" alt="App &amp; Test Container" /></p>
<p>There has to be a better way for in-container testing and there is.</p>
<h2 id="test-aware-container-approach">Test Aware Container Approach</h2>
<p>Today, Docker's promise is <strong>&quot;Build -&gt; Ship -&gt; Run&quot;</strong> - build the image, ship it to some registry, and run it anywhere. IMHO there's a critical missing step - <strong>Test</strong>. The right and complete sequence should be <strong>:Build -&gt; Test -&gt; Ship -&gt; Run</strong>.</p>
<p>Let's look at a &quot;test-friendly&quot; Dockerfile syntax and extensions to Docker commands. This important step could be supported natively. It's not a real syntax, but bear with me. I'll define the &quot;ideal&quot; version and show how to implement something that's very close.</p>
<pre><code>ONTEST [INSTRUCTION]
</code></pre>
<p>Let's define a special <code>ONTEST</code> instruction, similar to existing <a href="https://docs.docker.com/engine/reference/builder/#onbuild"><code>ONBUILD</code></a> instruction. The <code>ONTEST</code> instruction adds a trigger instruction to the image to be executed at a later time when the image is tested. Any build instruction can be registered as a trigger.</p>
<p>The <code>ONTEST</code> instruction should be recognized by a new <code>docker test</code> command.</p>
<pre><code>docker test [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre>
<p>The <code>docker test</code> command syntax will be similar to <code>docker run</code> command, with one significant difference: a new &quot;testable&quot; image will be automatically generated and even tagged with <code>&lt;image name&gt;:&lt;image tag&gt;-test</code> tag (&quot;test&quot; postfix added to the original image tag). This &quot;testable&quot; image will generated <code>FROM</code> the application image, executing all build instructions, defined after <code>ONTEST</code> command and executing <code>ONTEST CMD</code> (or <code>ONTEST ENTRYPOINT</code>).
The <code>docker test</code> command should return a non-zero code if any tests fail. The test results should be written into an automatically generated <code>VOLUME</code> that points to <code>/var/tests/results</code> folder.</p>
<p>Let's look at a modified <code>Dockerfile</code> below - it includes the new proposed <code>ONTEST</code> instruction.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> "&lt;base image&gt;":"&lt;version&gt;"</span>

<span class="k">WORKDIR</span><span class="s"> "&lt;path&gt;"</span>

<span class="c"># install packages required to run app</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\
</span>    <span class="s2">"&lt;app runtime&gt; and &lt;dependencies&gt;"</span> <span class="se">\ </span> <span class="c"># add app runtime and required packages</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# install packages required to run tests   
ONTEST RUN apt-get update &amp;&amp; apt-get install -y \
           "&lt;test tools&gt; and &lt;dependencies&gt;"    \     # add testing tools and required packages
           &amp;&amp; rm -rf /var/lib/apt/lists/*

# copy app files
<span class="k">COPY</span><span class="s"> app app</span>
<span class="k">COPY</span><span class="s"> run.sh run.sh</span>

<span class="c"># copy test scripts</span>
ONTEST COPY tests tests

<span class="c"># copy "main" test command</span>
ONTEST COPY test.sh test.sh

<span class="c"># auto-generated volume for test results</span>
<span class="c"># ONTEST VOLUME "/var/tests/results"</span>

<span class="c"># ... EXPOSE, RUN, ADD ... for app and test environment</span>

<span class="c"># main app command</span>
<span class="k">CMD</span><span class="s"> [run.sh, "&lt;app arguments&gt;"]</span>

<span class="c"># main test command</span>
ONTEST CMD [/test.sh, "&lt;test arguments&gt;"]
</code></pre></div></div>
<p><a href="https://gist.github.com/alexei-led/4f39cca8a03b1503978a">Dockerfile</a></p>
<p><img src="/assets/images/test_aware.png" alt="Test Aware Container" /></p>
<h3 id="making-quottest-aware-containerquot-real">Making &quot;Test Aware Container&quot; Real</h3>
<p>We believe Docker should make <code>docker-test</code> part of the container management lifecycle. There is a need to have a simple working solution today and I'll describe one that's very close to the ideal state.</p>
<p>As mentioned before, Docker has a very useful <code>ONBUILD</code> instruction. This instruction allows us to trigger another build instruction on succeeding builds. The basic idea is to use <code>ONBUILD</code> instruction when running <code>docker-test</code> command.</p>
<p>The flow executed by <code>docker-test</code> command:</p>
<ol>
<li><code>docker-test</code> will search for <code>ONBUILD</code> instructions in application <code>Dockerfile</code> and will ...</li>
<li>generate a temporary <code>Dockerfile.test</code> from original <code>Dockerfile</code></li>
<li>execute <code>docker build -f Dockerfile.test [OPTIONS] PATH</code> with additional options supported by <code>docker build</code> command: <code>-test</code> that will be automatically appended to <code>tag</code> option</li>
<li>If build is successful, execute <code>docker run -v ./tests/results:/var/tests/results [OPTIONS] IMAGE:TAG-test [COMMAND] [ARG...]</code></li>
<li>Remove <code>Dockerfile.test</code> file</li>
</ol>
<p>Why not create a new <code>Dockerfile.test</code> without requiring the <code>ONBUILD</code> instruction?</p>
<p>Because in order to test right image (and tag) we'll need to keep <code>FROM</code> always updated to <strong>image:tag</strong> that we want to test. This is not trivial.</p>
<p>There is a limitation in the described approach - it's not suitable for &quot;onbuild&quot; images (images used to automatically build your app), like <a href="https://hub.docker.com/_/maven/">Maven:onbuild</a></p>
<p>Let's look at a simple implementation of <code>docker-test</code> command. It highlights the concept: the <code>docker-test</code> command should be able to handle <code>build</code> and <code>run</code> command options and be able to handle errors properly.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">image</span><span class="o">=</span><span class="s2">"app"</span>
<span class="nv">tag</span><span class="o">=</span><span class="s2">"latest"</span>

<span class="nb">echo</span> <span class="s2">"FROM </span><span class="k">${</span><span class="nv">image</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">tag</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> Dockerfile.test <span class="o">&amp;&amp;</span>
docker build <span class="nt">-t</span> <span class="s2">"</span><span class="k">${</span><span class="nv">image</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">tag</span><span class="k">}</span><span class="s2">-test"</span> <span class="nt">-f</span> Dockerfile.test <span class="nb">.</span> <span class="o">&amp;&amp;</span>
docker run <span class="nt">-it</span> <span class="nt">--rm</span> <span class="nt">-v</span> <span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/tests/results:/var/tests/results <span class="s2">"</span><span class="k">${</span><span class="nv">image</span><span class="k">}</span><span class="s2">:</span><span class="k">${</span><span class="nv">tag</span><span class="k">}</span><span class="s2">-test"</span> <span class="o">&amp;&amp;</span>
<span class="nb">rm </span>Dockerfile.test
</code></pre></div></div>
<p>Let's focus on the most interesting and relevant part.</p>
<h2 id="integration-test-container">Integration Test Container</h2>
<p>Let's say we have an application built from tens or hundreds of microservices. Let's say we have an automated CI/CD pipeline, where each microservice is built and tested by our CI and deployed into some environment (testing, staging or production) after the build and tests pass. Pretty cool, eh?
Our CI tests are capable of testing each microservice in isolation - running unit and service tests (or API contract tests). Maybe even micro-integration tests - tests run on subsystem are created in ad-hoc manner (for example with <code>docker compose</code> help).</p>
<p>This leads to some issues that we need to address:</p>
<ul>
<li>What about real integration tests or long running tests (like performance and stress)?</li>
<li>What about resilience tests (&quot;chaos monkey&quot; like tests)?</li>
<li>Security scans?</li>
<li>What about test and scan activities that take time and should be run on a fully operational system?</li>
</ul>
<p>There should be a better way than just dropping a new microservice version into production and tightly monitoring it for a while.</p>
<p>There should be a special <strong>Integration Test Container</strong>. These containers will contain only testing tools and test artifacts: test scripts, test data, test environment configuration, etc. To simplify orchestration and automation of such containers, we should define and follow some conventions and use metadata labels (Dockerfile <code>LABEL</code> instruction).</p>
<h3 id="integration-test-labels">Integration Test Labels</h3>
<ul>
<li><strong>test.type</strong> - test type; default <code>integration</code>; can be one of: <code>integration</code>, <code>performance</code>, <code>security</code>, <code>chaos</code> or any text; presence of this label states that this is an <strong>Integration Test Container</strong></li>
<li><strong>test.results</strong> - <code>VOLUME</code> for test results; default <code>/var/tests/results</code></li>
<li><strong>test.XXX</strong> - any other test related metadata; just use <strong>test.</strong> prefix for label name</li>
</ul>
<h3 id="integration-test-container-1">Integration Test Container</h3>
<p>The <strong>Integration Test Container</strong> is just a regular Docker container. Tt does not contain any application logic and code. Its sole purpose is to create repeatable and portable testing. Recommended content of the <strong>Integration Test Container</strong>:</p>
<ul>
<li><em>The Testing Tool</em> - Phantom.js, Selenium, Chakram, Gatling, ...</li>
<li><em>Testing Tool Runtime</em> - Node.js, JVM, Python, Ruby, ...</li>
<li><em>Test Environment Configuration</em> - environment variables, config files, bootstrap scripts, ...</li>
<li><em>Tests</em> - as compiled packages or script files</li>
<li><em>Test Data</em> - any kind of data files, used by tests: json, csv, txt, xml, ...</li>
<li><em>Test Startup Script</em> - some &quot;main&quot; startup script to run tests; just create <code>test.sh</code> and launch the testing tool from it.</li>
</ul>
<p><strong>Integration Test Containers</strong> should run in an operational environment where all microservices are deployed: testing, staging or production. These containers can be deployed exactly as all other services. They use same network layer and thus can access multiple services; using selected service discovery method (usually DNS). Accessing multiple services is required for real integration testing - we need to simulate and validate how our system is working in multiple places. Keeping integration tests inside some application service container not only increases the container footprint but also creates an unneeded dependency between multiple services. We keep all these dependencies at the level of the <strong>Integration Test Container</strong>. Once our tests (and testing tools) are packaged inside the container, we can always rerun the same tests on any environment including the developer machine. You can always go back in time and rerun a specific version of <strong>Integration Test Container</strong>.</p>
<p><img src="/assets/images/int_test.png" alt="Integration Test Container" /></p>
<p>WDYT? Your feedback, particularly on standardizing the <code>docker-test</code> command, is greatly appreciated.</p>

  </div><a class="u-url" href="/development/2016/03/07/docker-testing.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Alexei Lednev</li><li><a class="u-email" href="mailto:alexei.led@gmail.com">alexei.led@gmail.com</a></li></ul>
      </div>

      <div class="footer-col">
        <p>Alexei Ledenev&#39;s blog</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
      <a href="https://github.com/alexei-led" title="GitHub">
        <svg class="svg-icon grey">
          <use xlink:href="/assets/minima-social-icons.svg#github"></use>
        </svg>
        <span class="username">Github</span>
      </a>
    </li></ul></div>
  </div>
</footer></body>

</html>
